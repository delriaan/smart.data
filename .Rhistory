taxonomy.rule = function(term.map = NULL, update = FALSE, show = FALSE, chatty = FALSE){
# @def self$smart.rules$for_usage ~ term.map + fields<character[][]>
# @def .law: An expression representing the actions to take when enforced
# Check for pre-existing term map ====
.map_exists <- hasName(self$smart.rules, "for_usage");
.default_map <- { data.table::data.table(
term = c("identifier", "demographic", "flag", "event.date", "category", "join.key")
, desc = { c(
"Identifies unique instances of a type of reference"
, "Demographic details such as name, date of birth, race, gender"
, "Logical indicator"
, "The event dates or duration boundary dates"
, "Indicates a categorical variable"
, "Indicates the field(s) to use for 'data.table' joins"
)}
, rule = replicate(6, rlang::expr(x))
, fields = replicate(6, list(character()))
, key = "term"
)
}
if (.map_exists) {
.default_map <- data.table::rbindlist(list(
.default_map[!(term %in% self$smart.rules$for_usage$term)]
, self$smart.rules$for_usage
), use.names = TRUE)
}
# Check to see if a naming rule exists: if so, the taxonomy fields need to follow the law of naming ====
if ("for_naming" %in% names(self$smart.rules)){
if (attr(self$smart.rules$for_naming, "state") == "pending"){
self$enforce.rules(for_naming, chatty = chatty)
}
if (!purrr::is_empty(term.map)){
term.map <- term.map[, fields := purrr::map(fields, \(x){
purrr::modify_if(
x
, \(i) !rlang::is_empty(i)
, \(i){ stringi::stri_replace_all_fixed(
i
, pattern = self$smart.rules$for_naming
, replacement = names(self$smart.rules$for_naming)
, vectorize_all = FALSE
)
}
)}
)]
}
# Validate and process 'term.map' ====
if (!purrr::is_empty(term.map)){
if (!data.table::is.data.table(term.map)){ data.table::setDT(term.map) }
if (rlang::is_empty(intersect(c("term", "desc"), names(term.map)))){
stop("Error: each taxonomy must have the following fields provided: term, desc");
} else {
term.map[, c("term", "desc") := purrr::map(mget(c("term", "desc")), unlist)]
}
# term.map <- term.map[(if (!update){ !term %in% .default_map$term })]; # Add or update terms (anything remaining when not updating is added)
} else {
term.map <- .default_map
}
term.map[, rule := rlang::expr(x)]
# Update the term map?
if (update){
# Update or retain current/default
term.map <- data.table::rbindlist(list(.default_map[!(term %in% term.map$term)], term.map), use.names = TRUE, fill = TRUE)
}
data.table::setkey(term.map, term);
# Define/Update the taxonomy ====
.taxonomy <- {
# Choose the values of 'term' to define/update
.term_list = {
tcltk::tk_select.list(
choices = term.map$term
, preselect = if (update){ term.map[purrr::map_lgl(term.map$fields, \(x) any(!purrr::is_empty(unlist(x)))), term] }
, multiple = TRUE
, title = paste0("Choose one or more terms to map to fields in ", self$name)
) |>
purrr::compact() |> (\(x){
if (purrr::is_empty(x)){
message("Nothing selected: existing terms retained.");
term.map$term
} else { x }
})()
}
# Populate 'fields' for each term
term.map[(term %in% .term_list)][
, fields := purrr::map2(term, fields, \(x, y){
.out = if (any(purrr::is_empty(unlist(y))) || update){
tcltk::tk_select.list(
choices = names(self$data)
, title = sprintf("Choose term [%s] fields", x)
, preselect = if (!identical(character(), unlist(y))){ unlist(y) }
, multiple = TRUE
)
} else { unlist(y) }
if (purrr::is_empty(.out)){ NA } else { list(c(.out)) }
})
][!is.na(fields)][, fields := purrr::map(fields, unlist)];
}
self$smart.rules$for_usage <- .taxonomy;
if (show){ print(self$smart.rules$for_usage) }
data.table::setattr(self$smart.rules$for_usage, "law", rlang::expr());
data.table::setattr(self$smart.rules$for_usage, "state", "pending");
invisible(self);
}
# Test :: Manual Slot Assignment
self$smart.rules$for_usage$flag@fields <- c("mpg", "qsec")
name_map <- { setClass(
Class = "name_map"
, slots = list(
name_map = "list"
, law = "language"
, history = "list"
, state = "character"
)
, prototype = list(
name_map = list()
, law = rlang::expr(NULL)
, history = list()
, state = character()
)
)}
# :: Function Re-definitions <IN-PROGRESS>
naming.rule = function(..., show = FALSE){
.nms <- rlang::list2(...)
cur_law <- attr(self$smart.rules$for_naming, "law")
if (rlang::is_empty(cur_law)){
attr(cur_law, "field_names", names(self$data))
}
new_law <- rlang::expr(data.table::setnames(
x = self$data
, old = !!unlist(.nms, use.names = FALSE)
, new = !!names(.nms)
, skip_absent = TRUE
)) |>
data.table::setattr("field_names", names(.nms))
self$smart.rules$for_naming <- name_map(
name_map = .nms
, law = new_law
, history = list(new_law, cur_law)
, state = "pending"
)
invisible(self)
}
naming.rule = function(..., show = FALSE){
.nms <- rlang::list2(...)
cur_law <- attr(self$smart.rules$for_naming, "law")
if (rlang::is_empty(cur_law)){
attr(cur_law, "field_names", names(self$data))
}
new_law <- rlang::expr(data.table::setnames(
x = self$data
, old = !!unlist(.nms, use.names = FALSE)
, new = !!names(.nms)
, skip_absent = TRUE
)) |>
data.table::setattr("field_names", names(.nms))
self$smart.rules$for_naming <- name_map(
name_map = .nms
, law = new_law
, history = list(new_law, cur_law)
, state = "pending"
)
if (show){ print(new_law) }
invisible(self)
}
names(self$data)
naming.rule = function(..., show = FALSE){
.nms <- rlang::dots_list(..., .named = TRUE)
cur_law <- attr(self$smart.rules$for_naming, "law")
if (rlang::is_empty(cur_law)){
attr(cur_law, "field_names", names(self$data))
}
new_law <- rlang::expr(data.table::setnames(
x = self$data
, old = !!unlist(.nms, use.names = FALSE)
, new = !!names(.nms)
, skip_absent = TRUE
)) |>
data.table::setattr("field_names", names(.nms))
self$smart.rules$for_naming <- name_map(
name_map = .nms
, law = new_law
, history = list(new_law, cur_law)
, state = "pending"
)
if (show){ print(new_law) }
invisible(self)
}
names(self$data)
book.of.utilities::enlist(names(self$data), "fuel_efficiency",,"displacement","horsepower")
book.of.utilities::enlist(names(self$data), "fuel_efficiency",,"displacement","horsepower",,,,,,"CARB")
book.of.utilities::enlist(names(self$data), "fuel_efficiency",,"displacement","horsepower",,,,,"CARB")
book.of.utilities::enlist(names(self$data), "fuel_efficiency","","displacement","horsepower","","","","","CARB")
book.of.utilities::enlist(
names(self$data)
, "fuel_efficiency"
,""
,"displacement"
,"horsepower"
,"","","",""
,"AM", "GEARS"
,"CARB"
)
book.of.utilities::enlist(
names(self$data)
,"fuel_efficiency"
,
,"displacement"
,"horsepower"
,,,,
,"AM", "GEARS"
,"CARB"
)
mynames <- book.of.utilities::enlist(names(self$data),"fuel_efficiency",,"displacement","horsepower",,,,,"AM", "GEARS","CARB")
naming.rule(!!!mynames, show = TRUE)
self$smart.rules$for_naming@history
self$smart.rules$for_naming@history |> unique()
self$smart.rules$for_naming@law
self$smart.rules$for_naming@state
# Function re-definitions <IN-PROGRESS>
naming.rule = function(..., show = FALSE){
.nms <- rlang::dots_list(..., .named = TRUE)
cur_law <- self$smart.rules$for_naming@law
cur_names <- if (rlang::is_empty(cur_law)){
rlang::set_names(names(self$data)) |> as.list()
} else { self$smart.rules$for_naming@history }
new_law <- { rlang::expr(data.table::setnames(
x = self$data
, old = !!unlist(.nms, use.names = FALSE)
, new = !!names(.nms)
, skip_absent = TRUE
))
}
self$smart.rules$for_naming <- { name_map(
name_map = .nms
, law = new_law
, history = data.table::rbindlist(list(.nms, cur_names))
, state = "pending"
)}
if (show){ print(new_law) }
invisible(self)
}
# Tests
mynames <- book.of.utilities::enlist(names(self$data),"fuel_efficiency",,"displacement","horsepower",,,,,"AM", "GEARS","CARB")
naming.rule(!!!mynames, show = TRUE)
rlang::set_names(names(self$data)) |> as.list()
self$smart.rules$for_naming@history
self <- new.env()
self$data <- data.table::as.data.table(mtcars)
self$smart.rules <- rlang::env(
for_naming = NULL
, for_transformation = list()
, for_usage = new.env()
)
# :: Naming <IN-PROGRESS> ----
# Class Definition
name_map <- { setClass(
Class = "name_map"
, slots = list(
name_map = "list"
, law = "language"
, history = "list"
, state = "character"
)
, prototype = list(
name_map = list()
, law = rlang::expr(NULL)
, history = list()
, state = character()
)
)}
naming.rule = function(..., show = FALSE){
.nms <- rlang::dots_list(..., .named = TRUE)
cur_law <- self$smart.rules$for_naming@law
cur_names <- if (rlang::is_empty(cur_law)){
rlang::set_names(names(self$data)) |> as.list()
} else { self$smart.rules$for_naming@history }
new_law <- { rlang::expr(data.table::setnames(
x = self$data
, old = !!unlist(.nms, use.names = FALSE)
, new = !!names(.nms)
, skip_absent = TRUE
))
}
self$smart.rules$for_naming <- { name_map(
name_map = .nms
, law = new_law
, history = data.table::rbindlist(list(.nms, cur_names))
, state = "pending"
)}
if (show){ print(new_law) }
invisible(self)
}
# Tests
mynames <- book.of.utilities::enlist(names(self$data),"fuel_efficiency",,"displacement","horsepower",,,,,"AM", "GEARS","CARB")
naming.rule(!!!mynames, show = TRUE)
# Function re-definitions <IN-PROGRESS>
naming.rule = function(..., show = FALSE){
.nms <- rlang::dots_list(..., .named = TRUE)
cur_law <- if (!rlang::is_empty(self$smart.rules$for_naming)){ self$smart.rules$for_naming@law } else { NULL }
cur_names <- if (rlang::is_empty(cur_law)){
rlang::set_names(names(self$data)) |> as.list()
} else { self$smart.rules$for_naming@history }
new_law <- { rlang::expr(data.table::setnames(
x = self$data
, old = !!unlist(.nms, use.names = FALSE)
, new = !!names(.nms)
, skip_absent = TRUE
))
}
self$smart.rules$for_naming <- { name_map(
name_map = .nms
, law = new_law
, history = data.table::rbindlist(list(.nms, cur_names))
, state = "pending"
)}
if (show){ print(new_law) }
invisible(self)
}
# Tests
mynames <- book.of.utilities::enlist(names(self$data),"fuel_efficiency",,"displacement","horsepower",,,,,"AM", "GEARS","CARB")
naming.rule(!!!mynames, show = TRUE)
self <- new.env()
self$data <- data.table::as.data.table(mtcars)
self$smart.rules <- rlang::env(
for_naming = NULL
, for_transformation = list()
, for_usage = new.env()
)
# :: Naming <IN-PROGRESS> ----
# Class Definition
name_map <- { setClass(
Class = "name_map"
, slots = list(
name_map = "list"
, law = "language"
, history = "list"
, state = "character"
)
, prototype = list(
name_map = list()
, law = rlang::expr(NULL)
, history = list()
, state = character()
)
)}
# Function re-definitions <IN-PROGRESS>
naming.rule = function(..., show = FALSE){
.nms <- rlang::dots_list(..., .named = TRUE)
cur_law <- if (!rlang::is_empty(self$smart.rules$for_naming)){ self$smart.rules$for_naming@law } else { NULL }
cur_names <- if (rlang::is_empty(cur_law)){
rlang::set_names(names(self$data)) |> as.list()
} else { self$smart.rules$for_naming@history }
new_law <- { rlang::expr(data.table::setnames(
x = self$data
, old = !!unlist(.nms, use.names = FALSE)
, new = !!names(.nms)
, skip_absent = TRUE
))
}
self$smart.rules$for_naming <- { name_map(
name_map = .nms
, law = new_law
, history = data.table::rbindlist(list(.nms, cur_names), use.names = FALSE) |> unique()
, state = "pending"
)}
if (show){ print(new_law) }
invisible(self)
}
# Tests
mynames <- book.of.utilities::enlist(names(self$data),"fuel_efficiency",,"displacement","horsepower",,,,,"AM", "GEARS","CARB")
naming.rule(!!!mynames, show = TRUE)
self$smart.rules$for_naming@history
self$smart.rules$for_naming@law
self$smart.rules$for_naming@state
#
self <- new.env()
self$data <- data.table::as.data.table(mtcars)
self$smart.rules <- rlang::env(
for_naming = NULL
, for_transformation = list()
, for_usage = new.env()
)
# :: Naming <IN-PROGRESS> ----
# Class Definition
name_map <- { setClass(
Class = "name_map"
, slots = list(
name_map = "list"
, law = "language"
, history = "list"
, state = "character"
)
, prototype = list(
name_map = list()
, law = rlang::expr(NULL)
, history = list()
, state = character()
)
)}
# Function re-definitions <IN-PROGRESS>
naming.rule = function(..., show = FALSE){
.nms <- rlang::dots_list(..., .named = TRUE)
cur_law <- if (!rlang::is_empty(self$smart.rules$for_naming)){ self$smart.rules$for_naming@law } else { NULL }
cur_names <- if (rlang::is_empty(cur_law)){
rlang::set_names(names(self$data)) |> as.list()
} else { self$smart.rules$for_naming@history }
new_law <- { rlang::expr(data.table::setnames(
x = self$data
, old = !!unlist(.nms, use.names = FALSE)
, new = !!names(.nms)
, skip_absent = TRUE
))
}
self$smart.rules$for_naming <- { name_map(
name_map = .nms
, law = new_law
, history = data.table::rbindlist(list(.nms, cur_names), use.names = FALSE) |> unique()
, state = "pending"
)}
if (show){ print(new_law) }
invisible(self)
}
# Tests
naming.rule(show = TRUE)
self$smart.rules$for_naming@history
self$smart.rules$for_naming@law
{names(self$data) %>% rlang::set_names(toupper(.))}
# Tests
naming.rule(!!!{names(self$data) %>% rlang::set_names(toupper(.))}, show = TRUE)
self$smart.rules$for_naming@history
self$smart.rules$for_naming@law
self$smart.rules$for_naming@state
colors
names(self$data) %>%
rlang::set_names(toupper(.)) %>%
rlang::set_names(sample(colors(), length(.)))
names(self$data) %>%
rlang::set_names(toupper(.))
names(self$data) %>%
rlang::set_names(toupper(.)) %>%
names() %>%
rlang::set_names(sample(colors(), length(.)))
naming.rule(!!!{
names(self$data) %>%
rlang::set_names(toupper(.)) %>%
names() %>%
rlang::set_names(sample(colors(), length(.)))
}, show = TRUE)
self$smart.rules$for_naming@history
taxonomy <- { setClass(
Class = "taxonomy"
, slots = list(
term = "language"
, desc = "character"
, fields = "character"
)
)}
# Class Instantiate
self$smart.rules$for_usage %$% {
# Test :: Class Instantiations
identifier <- new("taxonomy", term = rlang::sym("identifier"), desc = "Identifies unique instances of a type of reference")
flag <- new("taxonomy", term = rlang::sym("flag"), desc = "Logical indicator")
demographic <- new("taxonomy", term = rlang::sym("demographic"), desc = "Demographic details such as name, date of birth, race, gender")
category <- new("taxonomy", term = rlang::sym("category"), desc = "Indicates a categorical variable")
event.date <- new("taxonomy", term = rlang::sym("event.date"), desc = "The event dates or duration boundary dates")
join.key <- new("taxonomy", term = rlang::sym("join.key"), desc = "Indicates the field(s) to use for 'data.table' joins")
}
# Test: Finding old names in updated names using the naming history
self$smart.rules$for_naming@history
# Test: Finding old names in updated names using the naming history
self$smart.rules$for_naming@history |> purrr::keep(\(x) x %in% c("mpg", "qsec"))
# Test: Finding old names in updated names using the naming history
self$smart.rules$for_naming@history |> purrr::keep(\(x) any(x %in% c("mpg", "qsec")))
# Test: Finding old names in updated names using the naming history
(\(.needle){
purrr::map_chr(.needle, \(i){
purrr::keep(self$smart.rules$for_naming@history, \(x) i %in% x) |> names()
})
})(c("mpg", "qsec"))
class(TRUE)
taxonomy <- { setClass(
Class = "taxonomy"
, slots = list(
term = "language"
, desc = "character"
, fields = "character"
, law = "logical"
)
, prototype = list(
term = rlang::expr(NULL)
, desc = character()
, fields = character()
, law = TRUE
)
)}
self$smart.rules$for_usage %$% {
# Test :: Class Instantiations
identifier <- new("taxonomy", term = rlang::sym("identifier"), desc = "Identifies unique instances of a type of reference")
flag <- new("taxonomy", term = rlang::sym("flag"), desc = "Logical indicator")
demographic <- new("taxonomy", term = rlang::sym("demographic"), desc = "Demographic details such as name, date of birth, race, gender")
category <- new("taxonomy", term = rlang::sym("category"), desc = "Indicates a categorical variable")
event.date <- new("taxonomy", term = rlang::sym("event.date"), desc = "The event dates or duration boundary dates")
join.key <- new("taxonomy", term = rlang::sym("join.key"), desc = "Indicates the field(s) to use for 'data.table' joins")
}
self$smart.rules$for_usage$flag@fields <- c("mpg", "qsec")
(\(.needle){
purrr::map_chr(.needle, \(i){
purrr::keep(self$smart.rules$for_naming@history, \(x) i %in% x) |> names()
})
})(c("mpg", "qsec"))
self$smart.rules
is.taxonomy <- \(x) "taxonomy" %in% class(x)
