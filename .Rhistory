detach("package:book.of.utilities", unload = TRUE)
library(smart.data)
# ~ pkgdown ----
usethis::use_pkgdown()
pkgdown::build_site()
# ~ pkgdown ----
# usethis::use_pkgdown()
usethis::use_proprietary_license("Chionesu George")
library(smart.data)
library(smart.data)
pkgdown::build_site()
library(smart.data)
pkgdown::build_site()
library(smart.data)
pkgdown::build_site()
library(smart.data)
pkgdown::build_site()
library(smart.data)
pkgdown::build_site()
pkgdown::build_site()
library(smart.data)
library(smart.data)
pkgdown::build_site()
(!hasName(.GlobalEnv, ".___SMART___")
)
?hasName
library(smart.data)
orig.data <- mtcars;
#
# ~ PART I: Functionality Tests====
smrt <- smart.data$
new(orig.data, "smart cars")$
naming.rule(MPG = "mpg", chatty = TRUE)$
taxonomy.rule()$
enforce.rules(for_naming)$
transformation.rule(
add_col = this.data[, car_model := rownames(orig.data)[1:nrow(this.data)]]
, subset = this.data <<- this.data[1:10, ]
, update = TRUE
)$
enforce.rules(for_transformation)
smrt$taxonomy.rule(update = TRUE)
smrt$use(identifier, category)
#
# ~ PART II: Amending the Transformation Rule =====
smrt$transformation.rule(
change.case = this.data <<- this.data[, car_model := toupper(car_model)]
, add_index = this.data <<- this.data[, rec_idx := seq_along(car_model)]
, update = TRUE
);
View(smrt$smart.rules$for_transformation) # List should be length five ()
smrt$enforce.rules(for_usage, for_transformation, chatty = TRUE);
smrt$smart.rules$for_transformation %>% map(attr, "active") # All results should be 'FALSE'
smrt$data # Column 'car_model' should only contain numbers and upper-case characters
# ~ PART III: Using the Taxonomy and Resetting ====
smrt$reset(chatty = !TRUE)
View(smrt$smart.rules) # All top-level list elements should have attribute "state" set to "pending"; transformation rules should all have attribute "active" set to 'TRUE'
smrt$enforce.rules(for_transformation)$
enforce.rules(for_usage)$
data;
smrt$use(identifier)
smrt$use(identifier, category, retain = disp, chatty = TRUE) # Should be identical to previous output
debug(smrt$use)
smrt$use(identifier, category, retain = c(hp, mpg), chatty = TRUE) # Should contain the previous output + 'mpg'
smrt$use(omit = c(mpg), chatty = TRUE)
smrt$use(identifier, category, retain = c(cyl, am), omit = c(mpg, am), chatty = TRUE) # Should NOT contain 'mpg', or 'am'
smrt$use(retain = `*`, chatty = TRUE)
smrt$use()
# ~ PART IV: Taxonomy Inheritance ====
smrtr <- smart.data$new(smrt, "cars")
smrtr$taxonomy.rule(update = TRUE) # Taxonomy terms should be identical
# ~ PART V: Smart Cache ----
smrt$name <- "smart_cars"
smrt$cache_mgr(action = add)
get.smart(smart_cars)$use(retain = drat)
is.smart(smrt)
# library(smart.data)
# library(magrittr); library(stringi)
library(data.table); library(purrr); library(stringi, include.only = "%s+%")
library(book.of.utilities);
orig.data <- mtcars;
#
# ~ PART I: Functionality Tests====
smrt <- smart.data$
new(orig.data, "smart cars")$
naming.rule(MPG = "mpg", chatty = TRUE)$
taxonomy.rule()$
enforce.rules(for_naming)$
transformation.rule(
add_col = this.data[, car_model := rownames(orig.data)[1:nrow(this.data)]]
, subset = this.data <<- this.data[1:10, ]
, update = TRUE
)$
enforce.rules(for_transformation)
smrt$taxonomy.rule(update = TRUE)
smrt$use(identifier, category)
#
# ~ PART II: Amending the Transformation Rule =====
smrt$transformation.rule(
change.case = this.data <<- this.data[, car_model := toupper(car_model)]
, add_index = this.data <<- this.data[, rec_idx := seq_along(car_model)]
, update = TRUE
);
View(smrt$smart.rules$for_transformation) # List should be length five ()
smrt$enforce.rules(for_usage, for_transformation, chatty = TRUE);
smrt$smart.rules$for_transformation %>% map(attr, "active") # All results should be 'FALSE'
smrt$data # Column 'car_model' should only contain numbers and upper-case characters
# ~ PART III: Using the Taxonomy and Resetting ====
smrt$reset(chatty = !TRUE)
View(smrt$smart.rules) # All top-level list elements should have attribute "state" set to "pending"; transformation rules should all have attribute "active" set to 'TRUE'
smrt$enforce.rules(for_transformation)$
enforce.rules(for_usage)$
data;
smrt$use(identifier)
smrt$use(identifier, category, retain = disp, chatty = TRUE) # Should be identical to previous output
debug(smrt$use)
smrt$use(identifier, category, retain = c(hp, mpg), chatty = TRUE) # Should contain the previous output + 'mpg'
smrt$use(omit = c(mpg), chatty = TRUE)
smrt$use(identifier, category, retain = c(cyl, am), omit = c(mpg, am), chatty = TRUE) # Should NOT contain 'mpg', or 'am'
smrt$use(retain = `*`, chatty = TRUE)
smrt$use()
# ~ PART IV: Taxonomy Inheritance ====
smrtr <- smart.data$new(smrt, "cars")
smrtr$taxonomy.rule(update = TRUE) # Taxonomy terms should be identical
# ~ PART V: Smart Cache ----
smrt$name <- "smart_cars"
smrt$cache_mgr(action = add)
get.smart(smart_cars)$use(retain = drat)
is.smart(smrt)
# ~ PART V: Smart Cache ----
smrt$name <- "smart_cars"
smrt$cache_mgr(action = add)
get.smart(smart_cars)$use(retain = drat)
get.smart(smart_cars)
is.smart(smrt)
get.smart(smart_cars)$data
get.smart(smart_cars)
smrt$use(identifier, category)
smrt$use(identifier, category)
library(smart.data)
# library(smart.data)
# library(magrittr); library(stringi)
library(data.table); library(purrr); library(stringi, include.only = "%s+%")
library(book.of.utilities);
orig.data <- mtcars;
#
# ~ PART I: Functionality Tests====
smrt <- smart.data$
new(orig.data, "smart cars")$
naming.rule(MPG = "mpg", chatty = TRUE)$
taxonomy.rule()$
enforce.rules(for_naming)$
transformation.rule(
add_col = this.data[, car_model := rownames(orig.data)[1:nrow(this.data)]]
, subset = this.data <<- this.data[1:10, ]
, update = TRUE
)$
enforce.rules(for_transformation)
smrt$taxonomy.rule(update = TRUE)
smrt$use(identifier, category)
#
# ~ PART II: Amending the Transformation Rule =====
smrt$transformation.rule(
change.case = this.data <<- this.data[, car_model := toupper(car_model)]
, add_index = this.data <<- this.data[, rec_idx := seq_along(car_model)]
, update = TRUE
);
View(smrt$smart.rules$for_transformation) # List should be length five ()
smrt$enforce.rules(for_usage, for_transformation, chatty = TRUE);
smrt$smart.rules$for_transformation %>% map(attr, "active") # All results should be 'FALSE'
smrt$data # Column 'car_model' should only contain numbers and upper-case characters
# ~ PART III: Using the Taxonomy and Resetting ====
smrt$reset(chatty = !TRUE)
View(smrt$smart.rules) # All top-level list elements should have attribute "state" set to "pending"; transformation rules should all have attribute "active" set to 'TRUE'
smrt$enforce.rules(for_transformation)$
enforce.rules(for_usage)$
data;
smrt$use(identifier)
smrt$use(identifier, category, retain = disp, chatty = TRUE) # Should be identical to previous output
# debug(smrt$use)
smrt$use(identifier, category, retain = c(hp, mpg), chatty = TRUE) # Should contain the previous output + 'mpg'
smrt$use(omit = c(mpg), chatty = TRUE)
smrt$use(identifier, category, retain = c(cyl, am), omit = c(mpg, am), chatty = TRUE) # Should NOT contain 'mpg', or 'am'
smrt$use(retain = `*`, chatty = TRUE)
smrt$use(identifier, category)
# ~ PART IV: Taxonomy Inheritance ====
smrtr <- smart.data$new(smrt, "cars")
smrtr$taxonomy.rule(update = TRUE) # Taxonomy terms should be identical
# ~ PART V: Smart Cache ----
smrt$name <- "smart_cars"
smrt$cache_mgr(action = add)
get.smart(smart_cars)$use(retain = drat)
get.smart(smart_cars)$use(retain = drat)
ls(smrt)
smrt$use(retain = drat)
smrt$cache_mgr(action = add)
get.smart(smart_cars
)
get.smart(smart_cars)
smrt$name
smrt
.___SMART___$keys()
.___SMART___$get("smart_cars")
rlang::caller_env()$.___SMART___;
?env_unlock
env_unlock(as.environment("package:smart.data"))
rlang::env_unlock(as.environment("package:smart.data"))
rlang::env_is_locked(as.environment("package:smart.data"))
detach("package:smart.data", unload = TRUE)
library(smart.data)
rlang::env_is_locked(as.environment("package:smart.data"))
rlang::env_unlock(as.environment("package:smart.data"))
.pkg_env <- rlang::pkg_env("smart.data")
.cache_obj <- cachem::cache_layered(cachem::cache_mem(), ...);
.pkg_env <- rlang::pkg_env("smart.data")
.cache_obj <- cachem::cache_layered(cachem::cache_mem());
rlang::env_unlock(.pkg_env);
assign(x = ".___SMART___", value = .cache_obj, assign.env = .pkg_env);
assign(x = ".___SMART___", value = .cache_obj, envir = .pkg_env);
rlang::env_binding_unlock(.pkg_env, ".___SMART___")
rlang::env_lock(.pkg_env);
ls(.pkg_env)
ls(.pkg_env, all.names = TRUE)
detach("package:smart.data", unload = TRUE)
library(smart.data)
library(data.table); library(purrr); library(stringi, include.only = "%s+%")
library(book.of.utilities);
orig.data <- mtcars;
#
# ~ PART I: Functionality Tests====
smrt <- smart.data$
new(orig.data, "smart cars")$
naming.rule(MPG = "mpg", chatty = TRUE)$
taxonomy.rule()$
enforce.rules(for_naming)$
transformation.rule(
add_col = this.data[, car_model := rownames(orig.data)[1:nrow(this.data)]]
, subset = this.data <<- this.data[1:10, ]
, update = TRUE
)$
enforce.rules(for_transformation)
smrt$taxonomy.rule(update = TRUE)
smrt$use(identifier, category)
#
# ~ PART II: Amending the Transformation Rule =====
smrt$transformation.rule(
change.case = this.data <<- this.data[, car_model := toupper(car_model)]
, add_index = this.data <<- this.data[, rec_idx := seq_along(car_model)]
, update = TRUE
);
View(smrt$smart.rules$for_transformation) # List should be length five ()
smrt$enforce.rules(for_usage, for_transformation, chatty = TRUE);
smrt$smart.rules$for_transformation %>% map(attr, "active") # All results should be 'FALSE'
smrt$data # Column 'car_model' should only contain numbers and upper-case characters
# ~ PART III: Using the Taxonomy and Resetting ====
smrt$reset(chatty = !TRUE)
View(smrt$smart.rules) # All top-level list elements should have attribute "state" set to "pending"; transformation rules should all have attribute "active" set to 'TRUE'
smrt$enforce.rules(for_transformation)$
enforce.rules(for_usage)$
data;
smrt$use(identifier)
smrt$use(identifier, category, retain = disp, chatty = TRUE) # Should be identical to previous output
smrt$use(identifier)
# debug(smrt$use)
smrt$use(identifier, category, retain = c(hp, mpg), chatty = TRUE) # Should contain the previous output + 'mpg'
# debug(smrt$use)
smrt$use(identifier, category, retain = c(hp, mpg), chatty = TRUE) # Should contain the previous output + 'mpg'
smrt$use(omit = c(mpg), chatty = TRUE)
smrt$use(identifier, category, retain = c(cyl, am), omit = c(mpg, am), chatty = TRUE) # Should NOT contain 'mpg', or 'am'
smrt$use(retain = `*`, chatty = TRUE)
smrt$use()
# ~ PART IV: Taxonomy Inheritance ====
smrtr <- smart.data$new(smrt, "cars")
smrtr$taxonomy.rule(update = TRUE) # Taxonomy terms should be identical
# ~ PART V: Smart Cache ----
smrt$name <- "smart_cars"
smrt$cache_mgr(action = add)
get.smart()
get.smart(smart_cars)$use(retain = drat)
.___SMART___
`.___SMART___`
detach("package:smart.data", unload = TRUE)
library(smart.data)
# library(smart.data)
# library(magrittr); library(stringi)
library(data.table); library(purrr); library(stringi, include.only = "%s+%")
library(book.of.utilities);
orig.data <- mtcars;
# ~ PART V: Smart Cache ----
smrt$name <- "smart_cars"
smrt$cache_mgr(action = add)
detach("package:smart.data", unload = TRUE)
library(smart.data)
# library(smart.data)
# library(magrittr); library(stringi)
library(data.table); library(purrr); library(stringi, include.only = "%s+%")
library(book.of.utilities);
orig.data <- mtcars;
#
# ~ PART I: Functionality Tests====
smrt <- smart.data$
new(orig.data, "smart cars")$
naming.rule(MPG = "mpg", chatty = TRUE)$
taxonomy.rule()$
enforce.rules(for_naming)$
transformation.rule(
add_col = this.data[, car_model := rownames(orig.data)[1:nrow(this.data)]]
, subset = this.data <<- this.data[1:10, ]
, update = TRUE
)$
enforce.rules(for_transformation)
smrt$taxonomy.rule(update = TRUE)
smrt$use(identifier, category)
# ~ PART V: Smart Cache ----
smrt$name <- "smart_cars"
smrt$cache_mgr(action = add)
detach("package:smart.data", unload = TRUE)
library(smart.data)
# library(smart.data)
# library(magrittr); library(stringi)
library(data.table); library(purrr); library(stringi, include.only = "%s+%")
library(book.of.utilities);
orig.data <- mtcars;
#
# ~ PART I: Functionality Tests====
smrt <- smart.data$
new(orig.data, "smart cars")$
naming.rule(MPG = "mpg", chatty = TRUE)$
taxonomy.rule()$
enforce.rules(for_naming)$
transformation.rule(
add_col = this.data[, car_model := rownames(orig.data)[1:nrow(this.data)]]
, subset = this.data <<- this.data[1:10, ]
, update = TRUE
)$
enforce.rules(for_transformation)
# ~ PART V: Smart Cache ----
smrt$name <- "smart_cars"
smrt$cache_mgr(action = add)
debug(smrt$cache_mgr)
smrt$cache_mgr(action = add)
debug(add.cache)
rlang::caller_env()$self$cache
self
self$cache
.___SMART___
detach("package:smart.data", unload = TRUE)
library(smart.data)
# library(smart.data)
# library(magrittr); library(stringi)
library(data.table); library(purrr); library(stringi, include.only = "%s+%")
library(book.of.utilities);
orig.data <- mtcars;
#
# ~ PART I: Functionality Tests====
smrt <- smart.data$
new(orig.data, "smart cars")$
naming.rule(MPG = "mpg", chatty = TRUE)$
taxonomy.rule()$
enforce.rules(for_naming)$
transformation.rule(
add_col = this.data[, car_model := rownames(orig.data)[1:nrow(this.data)]]
, subset = this.data <<- this.data[1:10, ]
, update = TRUE
)$
enforce.rules(for_transformation)
# ~ PART V: Smart Cache ----
smrt$name <- "smart_cars"
smrt$cache_mgr(action = add)
# ~ PART IV: Taxonomy Inheritance ====
smrtr <- smart.data$new(smrt, "cars")
smrtr$taxonomy.rule(update = TRUE) # Taxonomy terms should be identical
# ~ PART V: Smart Cache ----
smrt$name <- "smart_cars"
smrt$cache_mgr(action = add)
get.smart(smart_cars)$use(retain = drat)
.___SMART___$keys()
.___SMART___$keys()
detach("package:smart.data", unload = TRUE)
library(smart.data)
# library(smart.data)
# library(magrittr); library(stringi)
library(data.table); library(purrr); library(stringi, include.only = "%s+%")
library(book.of.utilities);
orig.data <- mtcars;
#
# ~ PART I: Functionality Tests====
smrt <- smart.data$
new(orig.data, "smart cars")$
naming.rule(MPG = "mpg", chatty = TRUE)$
taxonomy.rule()$
enforce.rules(for_naming)$
transformation.rule(
add_col = this.data[, car_model := rownames(orig.data)[1:nrow(this.data)]]
, subset = this.data <<- this.data[1:10, ]
, update = TRUE
)$
enforce.rules(for_transformation)
# ~ PART IV: Taxonomy Inheritance ====
smrtr <- smart.data$new(smrt, "cars")
smrtr$taxonomy.rule(update = TRUE) # Taxonomy terms should be identical
smrt$name
# ~ PART V: Smart Cache ----
smrt$name <- "smart_cars"
smrt$cache_mgr(action = add)
get.smart(smart_cars)$use(retain = drat)
get.smart(smart_cars)
.___SMART___$get("smart_cars")
detach("package:smart.data", unload = TRUE)
library(smart.data)
# library(smart.data)
# library(magrittr); library(stringi)
library(data.table); library(purrr); library(stringi, include.only = "%s+%")
library(book.of.utilities);
orig.data <- mtcars;
#
# ~ PART I: Functionality Tests====
smrt <- smart.data$
new(orig.data, "smart cars")$
naming.rule(MPG = "mpg", chatty = TRUE)$
taxonomy.rule()$
enforce.rules(for_naming)$
transformation.rule(
add_col = this.data[, car_model := rownames(orig.data)[1:nrow(this.data)]]
, subset = this.data <<- this.data[1:10, ]
, update = TRUE
)$
enforce.rules(for_transformation)
# ~ PART IV: Taxonomy Inheritance ====
smrtr <- smart.data$new(smrt, "cars")
smrtr$taxonomy.rule(update = TRUE) # Taxonomy terms should be identical
# ~ PART V: Smart Cache ----
smrt$name <- "smart_cars"
smrt$cache_mgr(action = add)
get.smart(smart_cars)$use(retain = drat)
is.smart(smrt)
detach("package:smart.data", unload = TRUE)
library(smart.data)
pkgdown::build_site(pkg = "pkg", override = list(destination = "../docs"))
# library(smart.data)
# library(magrittr); library(stringi)
library(data.table); library(purrr); library(stringi, include.only = "%s+%")
library(book.of.utilities);
orig.data <- mtcars;
#
# ~ PART I: Functionality Tests====
smrt <- smart.data$
new(orig.data, "smart cars")$
naming.rule(MPG = "mpg", chatty = TRUE)$
taxonomy.rule()$
enforce.rules(for_naming)$
transformation.rule(
add_col = this.data[, car_model := rownames(orig.data)[1:nrow(this.data)]]
, subset = this.data <<- this.data[1:10, ]
, update = TRUE
)$
enforce.rules(for_transformation)
library(smart.data)
# library(smart.data)
# library(magrittr); library(stringi)
library(data.table); library(purrr); library(stringi, include.only = "%s+%")
library(book.of.utilities);
orig.data <- mtcars;
#
# ~ PART I: Functionality Tests====
smrt <- smart.data$
new(orig.data, "smart cars")$
naming.rule(MPG = "mpg", chatty = TRUE)$
taxonomy.rule()$
enforce.rules(for_naming)$
transformation.rule(
add_col = this.data[, car_model := rownames(orig.data)[1:nrow(this.data)]]
, subset = this.data <<- this.data[1:10, ]
, update = TRUE
)$
enforce.rules(for_transformation)
smrt$set()
.___SMART___$keys()
detach("package:smart.data", unload = TRUE)
library(smart.data)
# library(smart.data)
# library(magrittr); library(stringi)
library(data.table); library(purrr); library(stringi, include.only = "%s+%")
library(book.of.utilities);
orig.data <- mtcars;
#
# ~ PART I: Functionality Tests====
smrt <- smart.data$
new(orig.data, "smart cars")$
naming.rule(MPG = "mpg", chatty = TRUE)$
taxonomy.rule()$
enforce.rules(for_naming)$
transformation.rule(
add_col = this.data[, car_model := rownames(orig.data)[1:nrow(this.data)]]
, subset = this.data <<- this.data[1:10, ]
, update = TRUE
)$
enforce.rules(for_transformation)
# ~ PART IV: Taxonomy Inheritance ====
smrtr <- smart.data$new(smrt, "cars")
smrtr$taxonomy.rule(update = TRUE) # Taxonomy terms should be identical
# ~ PART V: Smart Cache ----
smrt$name <- "smart_cars"
smrt$cache_mgr(action = add)
get.smart(smart_cars)$use(retain = drat)
is.smart(smrt)
smrt$use()
smrt$use(retain = `*`, subset = cyl == 8)
smrt$use(retain = `*`, subset = cyl == 8 & carb == 4)
detach("package:smart.data", unload = TRUE)
library(smart.data)
pkgdown::build_site(pkg = "pkg", override = list(destination = "../docs"))
