names(smrt$data)
rlang::exprs(letters[1:10])
rlang::exprs(!!!letters[1:10])
rlang::syms(!!!letters[1:10])
rlang::syms(letters[1:10])
library(smart.data)
orig_data <- data.table::as.data.table(mtcars, keep.rownames = TRUE) |> data.table::setnames("rn", "make_model")
data_names <- (\(x) rlang::set_names(x, toupper(x)))(names(orig_data))
#
# ~ PART I: Functionality Tests ====
smrt <- smart.data$
new(x = orig_data, name = "smart_cars")$
naming.rule(!!!data_names)$
enforce.rules(for_naming)
names(smrt$data)
smrt$smart.rules$for_naming@law
smrt$taxonomy.rule(
identifier = new("taxonomy", term = "identifier", desc = "Identifies unique instances of a type of reference")
, flag = new("taxonomy", term = "flag", desc = "Logical indicator")
, demographic = new("taxonomy", term = "demographic", desc = "Demographic details such as name, date of birth, race, gender")
, category = new("taxonomy", term = "category", desc = "Indicates a categorical variable")
, event.date = new("taxonomy", term = "event.date", desc = "The event dates or duration boundary dates")
, join.key = new("taxonomy", term = "join.key", desc = "Indicates the field(s) to use for 'data.table' joins")
, gui = TRUE
)
smrt$smart.rules$for_usage %$% mget(ls())
smrt$enforce.rules(for_usage)
smrt$use() |> print()
rlang::exprs("a", "b")
rlang::syms("a", "b")
rlang::syms(c("a", "b"))
rlang::syms(c("a", "b") |> rlang::set_names())
smrt$data[, rlang::syms(c("CYL", "bAM") |> rlang::set_names())
]
smrt$data[, rlang::syms(c("CYL", "AM") |> rlang::set_names())]
smrt$data[, rlang::syms(c("CYL", "AM") |> rlang::set_names() |> eval())]
smrt$data[, rlang::exprs(c("CYL", "AM") |> rlang::set_names() |> eval())]
smrt$data[, rlang::exprs(CYL, AM, .named = TRUE) |> eval())]
smrt$data[, rlang::exprs(CYL, AM, .named = TRUE) |> eval()]
smrt$data[, rlang::exprs(CYL, AM, .named = TRUE)]
smrt$data[, "CYL"]
library(smart.data)
orig_data <- data.table::as.data.table(mtcars, keep.rownames = TRUE) |> data.table::setnames("rn", "make_model")
data_names <- (\(x) rlang::set_names(x, toupper(x)))(names(orig_data))
#
# ~ PART I: Functionality Tests ====
smrt <- smart.data$
new(x = orig_data, name = "smart_cars")$
naming.rule(!!!data_names)$
enforce.rules(for_naming)
names(smrt$data)
smrt$smart.rules$for_naming@law
smrt$taxonomy.rule(
identifier = new("taxonomy", term = "identifier", desc = "Identifies unique instances of a type of reference")
, flag = new("taxonomy", term = "flag", desc = "Logical indicator")
, demographic = new("taxonomy", term = "demographic", desc = "Demographic details such as name, date of birth, race, gender")
, category = new("taxonomy", term = "category", desc = "Indicates a categorical variable")
, event.date = new("taxonomy", term = "event.date", desc = "The event dates or duration boundary dates")
, join.key = new("taxonomy", term = "join.key", desc = "Indicates the field(s) to use for 'data.table' joins")
, gui = TRUE
)
smrt$smart.rules$for_usage %$% mget(ls())
smrt$enforce.rules(for_usage)
smrt$use() |> print()
smrt$use(identifier) |> print()
self$data[eval(rlang::enexpr(subset)), all_fields]
library(smart.data)
orig_data <- data.table::as.data.table(mtcars, keep.rownames = TRUE) |> data.table::setnames("rn", "make_model")
data_names <- (\(x) rlang::set_names(x, toupper(x)))(names(orig_data))
#
# ~ PART I: Functionality Tests ====
smrt <- smart.data$
new(x = orig_data, name = "smart_cars")$
naming.rule(!!!data_names)$
enforce.rules(for_naming)
names(smrt$data)
smrt$smart.rules$for_naming@law
smrt$taxonomy.rule(
identifier = new("taxonomy", term = "identifier", desc = "Identifies unique instances of a type of reference")
, flag = new("taxonomy", term = "flag", desc = "Logical indicator")
, demographic = new("taxonomy", term = "demographic", desc = "Demographic details such as name, date of birth, race, gender")
, category = new("taxonomy", term = "category", desc = "Indicates a categorical variable")
, event.date = new("taxonomy", term = "event.date", desc = "The event dates or duration boundary dates")
, join.key = new("taxonomy", term = "join.key", desc = "Indicates the field(s) to use for 'data.table' joins")
, gui = TRUE
)
smrt$smart.rules$for_usage %$% mget(ls())
smrt$enforce.rules(for_usage)
smrt$use() |> print()
smrt$use(identifier) |> print()
smrt$use(category) |> print()
smrt$use(category, omit="DISP", ) |> print()
smrt$use(category, identifier) |> print()
View(data.table)
View(data.table::data.table)
library(smart.data)
orig_data <- data.table::as.data.table(mtcars, keep.rownames = TRUE) |> data.table::setnames("rn", "make_model")
data_names <- (\(x) rlang::set_names(x, toupper(x)))(names(orig_data))
#
# ~ PART I: Functionality Tests ====
smrt <- smart.data$
new(x = orig_data, name = "smart_cars")$
naming.rule(!!!data_names)$
enforce.rules(for_naming)
names(smrt$data)
smrt$smart.rules$for_naming@law
smrt$taxonomy.rule(
identifier = new("taxonomy", term = "identifier", desc = "Identifies unique instances of a type of reference")
, flag = new("taxonomy", term = "flag", desc = "Logical indicator")
, demographic = new("taxonomy", term = "demographic", desc = "Demographic details such as name, date of birth, race, gender")
, category = new("taxonomy", term = "category", desc = "Indicates a categorical variable")
, event.date = new("taxonomy", term = "event.date", desc = "The event dates or duration boundary dates")
, join.key = new("taxonomy", term = "join.key", desc = "Indicates the field(s) to use for 'data.table' joins")
, gui = TRUE
)
smrt$smart.rules$for_usage %$% mget(ls())
smrt$enforce.rules(for_usage)
smrt$use() |> print()
smrt$use(identifier) |> print()
smrt$use(category) |> print()
smrt$use(category, omit="DISP", ) |> print()
smrt$use(category, identifier) |> print()
smrt$use(retain="*", omit="WT") |> print()
#
# ~ PART II: Using the Taxonomy and Resetting ====
smrt$get.history
smrt$reset(safe = TRUE)
names(smrt$data)
library(smart.data)
orig_data <- data.table::as.data.table(mtcars, keep.rownames = TRUE) |> data.table::setnames("rn", "make_model")
data_names <- (\(x) rlang::set_names(x, toupper(x)))(names(orig_data))
#
# ~ PART I: Functionality Tests ====
smrt <- smart.data$
new(x = orig_data, name = "smart_cars")$
naming.rule(!!!data_names)$
enforce.rules(for_naming)
names(smrt$data)
smrt$smart.rules$for_naming@law
smrt$taxonomy.rule(
identifier = new("taxonomy", term = "identifier", desc = "Identifies unique instances of a type of reference")
, flag = new("taxonomy", term = "flag", desc = "Logical indicator")
, demographic = new("taxonomy", term = "demographic", desc = "Demographic details such as name, date of birth, race, gender")
, category = new("taxonomy", term = "category", desc = "Indicates a categorical variable")
, event.date = new("taxonomy", term = "event.date", desc = "The event dates or duration boundary dates")
, join.key = new("taxonomy", term = "join.key", desc = "Indicates the field(s) to use for 'data.table' joins")
, gui = TRUE
)
smrt$smart.rules$for_usage %$% mget(ls())
smrt$enforce.rules(for_usage)
smrt$use() |> print()
smrt$use(identifier) |> print()
smrt$use(category) |> print()
library(smart.data)
orig_data <- data.table::as.data.table(mtcars, keep.rownames = TRUE) |> data.table::setnames("rn", "make_model")
data_names <- (\(x) rlang::set_names(x, toupper(x)))(names(orig_data))
#
# ~ PART I: Functionality Tests ====
smrt <- smart.data$
new(x = orig_data, name = "smart_cars")$
naming.rule(!!!data_names)$
enforce.rules(for_naming)
names(smrt$data)
smrt$smart.rules$for_naming@law
smrt$taxonomy.rule(
identifier = new("taxonomy", term = "identifier", desc = "Identifies unique instances of a type of reference")
, flag = new("taxonomy", term = "flag", desc = "Logical indicator")
, demographic = new("taxonomy", term = "demographic", desc = "Demographic details such as name, date of birth, race, gender")
, category = new("taxonomy", term = "category", desc = "Indicates a categorical variable")
, event.date = new("taxonomy", term = "event.date", desc = "The event dates or duration boundary dates")
, join.key = new("taxonomy", term = "join.key", desc = "Indicates the field(s) to use for 'data.table' joins")
, gui = TRUE
)
smrt$smart.rules$for_usage %$% mget(ls())
smrt$enforce.rules(for_usage)
smrt$use() |> print()
library(smart.data)
orig_data <- data.table::as.data.table(mtcars, keep.rownames = TRUE) |> data.table::setnames("rn", "make_model")
data_names <- (\(x) rlang::set_names(x, toupper(x)))(names(orig_data))
#
# ~ PART I: Functionality Tests ====
smrt <- smart.data$
new(x = orig_data, name = "smart_cars")$
naming.rule(!!!data_names)$
enforce.rules(for_naming)
names(smrt$data)
smrt$smart.rules$for_naming@law
smrt$taxonomy.rule(
identifier = new("taxonomy", term = "identifier", desc = "Identifies unique instances of a type of reference")
, flag = new("taxonomy", term = "flag", desc = "Logical indicator")
, demographic = new("taxonomy", term = "demographic", desc = "Demographic details such as name, date of birth, race, gender")
, category = new("taxonomy", term = "category", desc = "Indicates a categorical variable")
, event.date = new("taxonomy", term = "event.date", desc = "The event dates or duration boundary dates")
, join.key = new("taxonomy", term = "join.key", desc = "Indicates the field(s) to use for 'data.table' joins")
, gui = TRUE
)
smrt$smart.rules$for_usage %$% mget(ls())
smrt$enforce.rules(for_usage)
smrt$use() |> print()
smrt$use(identifier) |> print()
debug(smrt$use)
# smrt$enforce.rules(for_usage)
smrt$use() |> print()
all_fields
self$data[eval(rlang::enexpr(subset)), eval(all_fields)]
self$data[eval(rlang::enexpr(subset)), (all_fields)]
self$data[eval(rlang::enexpr(subset)), list(all_fields)]
data.table::is.data.table(self$data)
self$data[eval(rlang::enexpr(subset)), list(!!all_fields)]
self$data[eval(rlang::enexpr(subset)), list(!!!all_fields)]
self$data[eval(rlang::enexpr(subset)), rlang::list2(!!!all_fields)]
self$data[eval(rlang::enexpr(subset)), rlang::list2(!!all_fields)]
self$data[eval(rlang::enexpr(subset)), rlang::exprs(!!all_fields)]
self$data[eval(rlang::enexpr(subset)), rlang::expr(!!all_fields)]
self$data[eval(rlang::enexpr(subset)), as.call(!!all_fields)]
self$data[eval(rlang::enexpr(subset)), as.call(all_fields)]
self$data[eval(rlang::enexpr(subset)), substitute(all_fields)]
all_fields
all_fields |> rlang::eval_tidy(data = self$data)
rlang::as_quosures(all_fields, env = self$data)
rlang::as_quosures(all_fields, env = rlang::as_data_mask(self$data))
rlang::as_quosures(all_fields, env = rlang::as_data_mask(self$data)) |> rlang::eval_tidy()
rlang::as_quosures(all_fields, env = rlang::as_data_mask(self$data)) |> lapply(rlang::eval_tidy)
library(smart.data)
orig_data <- data.table::as.data.table(mtcars, keep.rownames = TRUE) |> data.table::setnames("rn", "make_model")
data_names <- (\(x) rlang::set_names(x, toupper(x)))(names(orig_data))
#
# ~ PART I: Functionality Tests ====
smrt <- smart.data$
new(x = orig_data, name = "smart_cars")$
naming.rule(!!!data_names)$
enforce.rules(for_naming)
names(smrt$data)
smrt$smart.rules$for_naming@law
smrt$taxonomy.rule(
identifier = new("taxonomy", term = "identifier", desc = "Identifies unique instances of a type of reference")
, flag = new("taxonomy", term = "flag", desc = "Logical indicator")
, demographic = new("taxonomy", term = "demographic", desc = "Demographic details such as name, date of birth, race, gender")
, category = new("taxonomy", term = "category", desc = "Indicates a categorical variable")
, event.date = new("taxonomy", term = "event.date", desc = "The event dates or duration boundary dates")
, join.key = new("taxonomy", term = "join.key", desc = "Indicates the field(s) to use for 'data.table' joins")
, gui = TRUE
)
# debug(smrt$use)
# smrt$smart.rules$for_usage %$% mget(ls())
smrt$enforce.rules(for_usage)
smrt$use() |> print()
smrt$use(identifier) |> print()
debug(smrt$use)
smrt$use() |> print()
lapply(all_fields, rlang::eval_tidy)
all_fields <- {
mget(term_list, envir = self$smart.rules$for_usage) |>
purrr::map(\(i) i@fields |> unlist()) |>
purrr::compact() |>
unlist(use.names = FALSE) |>
c(retain) |>
purrr::compact() |>
purrr::discard(\(i) i %in% omit) |>
unique() |>
rlang::exprs(named = TRUE) |>
rlang::as_quosures(env = self$data[eval(rlang::enexpr(subset))])
}
all_fields <- {
mget(term_list, envir = self$smart.rules$for_usage) |>
purrr::map(\(i) i@fields |> unlist()) |>
purrr::compact() |>
unlist(use.names = FALSE) |>
c(retain) |>
purrr::compact() |>
purrr::discard(\(i) i %in% omit) |>
unique() |>
rlang::exprs(named = TRUE) |>
rlang::as_quosures(env = rlang::as_data_mask(self$data[eval(rlang::enexpr(subset))]))
}
lapply(all_fields, rlang::eval_tidy)
all_fields <- {
mget(term_list, envir = self$smart.rules$for_usage) |>
purrr::map(\(i) i@fields |> unlist()) |>
purrr::compact() |>
unlist(use.names = FALSE) |>
c(retain) |>
purrr::compact() |>
purrr::discard(\(i) i %in% omit) |>
unique() |>
rlang::exprs(named = TRUE)
}
mget(term_list, envir = self$smart.rules$for_usage) |>
purrr::map(\(i) i@fields |> unlist()) |>
purrr::compact() |>
unlist(use.names = FALSE) |>
c(retain) |>
purrr::compact() |>
purrr::discard(\(i) i %in% omit) |>
unique()
mget(term_list, envir = self$smart.rules$for_usage) |>
purrr::map(\(i) i@fields |> unlist()) |>
purrr::compact() |>
unlist(use.names = FALSE) |>
c(retain) |>
purrr::compact() |>
purrr::discard(\(i) i %in% omit) |>
unique() |> rlang::syms() |> rlang::as_quosures()
mget(term_list, envir = self$smart.rules$for_usage) |>
purrr::map(\(i) i@fields |> unlist()) |>
purrr::compact() |>
unlist(use.names = FALSE) |>
c(retain) |>
purrr::compact() |>
purrr::discard(\(i) i %in% omit) |>
unique() |> rlang::syms() |> rlang::as_quosures(env = rlang::as_data_mask(self$data[eval(rlang::enexpr(subset))]))
all_fields <- mget(term_list, envir = self$smart.rules$for_usage) |>
purrr::map(\(i) i@fields |> unlist()) |>
purrr::compact() |>
unlist(use.names = FALSE) |>
c(retain) |>
purrr::compact() |>
purrr::discard(\(i) i %in% omit) |>
unique() |> rlang::syms() |> rlang::as_quosures(env = rlang::as_data_mask(self$data[eval(rlang::enexpr(subset))]))
all_fields$AM
all_fields[[1]]
lapply(all_fields, rlang::eval_tidy)
all_fields <- mget(term_list, envir = self$smart.rules$for_usage) |>
purrr::map(\(i) i@fields |> unlist()) |>
purrr::compact() |>
unlist(use.names = FALSE) |>
c(retain) |>
purrr::compact() |>
purrr::discard(\(i) i %in% omit) |>
unique() |>
rlang::syms() |>
rlang::as_quosures(
env = rlang::as_data_mask(self$data[eval(rlang::enexpr(subset))])
, named = TRUE
)
data.table::data.table(lapply(all_fields, rlang::eval_tidy))
data.table::as.data.table(lapply(all_fields, rlang::eval_tidy))
library(smart.data)
orig_data <- data.table::as.data.table(mtcars, keep.rownames = TRUE) |> data.table::setnames("rn", "make_model")
data_names <- (\(x) rlang::set_names(x, toupper(x)))(names(orig_data))
#
# ~ PART I: Functionality Tests ====
smrt <- smart.data$
new(x = orig_data, name = "smart_cars")$
naming.rule(!!!data_names)$
enforce.rules(for_naming)
names(smrt$data)
smrt$smart.rules$for_naming@law
smrt$taxonomy.rule(
identifier = new("taxonomy", term = "identifier", desc = "Identifies unique instances of a type of reference")
, flag = new("taxonomy", term = "flag", desc = "Logical indicator")
, demographic = new("taxonomy", term = "demographic", desc = "Demographic details such as name, date of birth, race, gender")
, category = new("taxonomy", term = "category", desc = "Indicates a categorical variable")
, event.date = new("taxonomy", term = "event.date", desc = "The event dates or duration boundary dates")
, join.key = new("taxonomy", term = "join.key", desc = "Indicates the field(s) to use for 'data.table' joins")
, gui = TRUE
)
# debug(smrt$use)
# smrt$smart.rules$for_usage %$% mget(ls())
smrt$enforce.rules(for_usage)
smrt$use() |> print()
smrt$use(identifier) |> print()
smrt$use(category) |> print()
smrt$use(category, omit="DISP", ) |> print()
smrt$use(category, identifier) |> print()
smrt$use(category) |> print()
smrt$use(category, omit="DISP", ) |> print()
smrt$use(category, identifier) |> print()
smrt$use(identifier) |> print()
smrt$use(retain="*", omit="WT") |> print()
debug(smrt$use)
smrt$use(category, identifier) |> print()
mget(term_list, envir = self$smart.rules$for_usage) |>
purrr::map(\(i) i@fields |> unlist()) |>
purrr::compact()
mget(term_list, envir = self$smart.rules$for_usage)
rlang::enexprs(...) |> .checkout()
rlang::enexprs(...)
rlang::enexprs(...) |> is.list()
library(smart.data)
orig_data <- data.table::as.data.table(mtcars, keep.rownames = TRUE) |> data.table::setnames("rn", "make_model")
data_names <- (\(x) rlang::set_names(x, toupper(x)))(names(orig_data))
#
# ~ PART I: Functionality Tests ====
smrt <- smart.data$
new(x = orig_data, name = "smart_cars")$
naming.rule(!!!data_names)$
enforce.rules(for_naming)
names(smrt$data)
smrt$smart.rules$for_naming@law
smrt$taxonomy.rule(
identifier = new("taxonomy", term = "identifier", desc = "Identifies unique instances of a type of reference")
, flag = new("taxonomy", term = "flag", desc = "Logical indicator")
, demographic = new("taxonomy", term = "demographic", desc = "Demographic details such as name, date of birth, race, gender")
, category = new("taxonomy", term = "category", desc = "Indicates a categorical variable")
, event.date = new("taxonomy", term = "event.date", desc = "The event dates or duration boundary dates")
, join.key = new("taxonomy", term = "join.key", desc = "Indicates the field(s) to use for 'data.table' joins")
, gui = TRUE
)
# debug(smrt$use)
# smrt$smart.rules$for_usage %$% mget(ls())
smrt$enforce.rules(for_usage)
smrt$use() |> print()
smrt$use(identifier) |> print()
smrt$use(category) |> print()
smrt$use(category, omit="DISP", ) |> print()
smrt$use(category) |> print()
smrt$use(category, identifier) |> print()
smrt$use(retain="*", omit="WT") |> print()
#
# ~ PART II: Using the Taxonomy and Resetting ====
smrt$get.history
smrt$reset(safe = TRUE)
names(smrt$data)
smrt$smart.rules$for_naming@state
smrt$
naming.rule(!!!data_names)$
enforce.rules(for_naming)
names(smrt$data)
# ~ PART III: Smart Cache ----
get.smart(smart_cars)$use(retain="*") |> print()
# ~ PART III: Smart Cache ----
get.smart(smart_cars)$use() |> print()
# ~ PART III: Smart Cache ----
smrt$name <- "smart_cars"
is.smart(smrt)
smrt$cache_mgr(action = upd)
get.smart(smart_cars)$data
library(smart.data)
pkgdown::build_site(pkg = "pkg", override = list(destination = "../docs"))
library(smart.data)
pkgdown::build_site(pkg = "pkg", override = list(destination = "../docs"))
as.name_map(list(name_map = c(A = "a", B = "z")))
as.name_map(list(name_map = c(A = "a", B = "z")), law = rlang::expr())
as.name_map(list(name_map = c(A = "a", B = "z"), law = rlang::expr()))
as.name_map(list(name_map = c(A = "a", B = "z"), law = rlang::expr(ls())))
rlang::expr(c())
as.name_map(list(name_map = c(A = "a", B = "z"), law = rlang::expr(NULL)))
as.name_map(list(name_map = c(A = "a", B = "z"), law = rlang::expr(\())))
as.name_map(list(name_map = c(A = "a", B = "z"), law = rlang::expr((\()))))
as.name_map(list(name_map = c(A = "a", B = "z"), law = rlang::expr((\(X)))))
as.name_map(list(name_map = c(A = "a", B = "z"), law = rlang::expr((\(X))))
as.name_map(list(name_map = c(A = "a", B = "z"), law = rlang::expr(eval()))
)
as.taxonomy(list(term = "test_term", desc = "test_description"))
as.name_map(list(name_map = c(A = "a", B = "z"), law = rlang::expr(eval()))
)
as.name_map(list(name_map = c(A = "a", B = "z"), law = rlang::expr(eval())))
identifier <- smart.data::as.taxonomy(list(term = "identifier", desc = "Identifies unique instances in a set"))
jsonlite::toJSON(as.list(identifier) |> purrr::modify_at("law", rlang::expr_deparse))
jsonlite::toJSON(as.list(identifier) |> purrr::modify_at("law", rlang::expr_deparse)) |> smart.data::as.taxonomy()
jsonlite::toJSON(as.list(identifier) |> purrr::modify_at("law", rlang::expr_deparse))
jsonlite::toJSON(as.list(identifier) |> purrr::modify_at("law", rlang::expr_deparse)) |> as.taxonomy()
jsonlite::toJSON(as.list(identifier) |> purrr::modify_at("law", rlang::expr_deparse)) |> jsonlite::fromJSON(x) |>
purrr::modify_at("law", str2lang)
jsonlite::toJSON(as.list(identifier) |> purrr::modify_at("law", rlang::expr_deparse)) |> jsonlite::fromJSON() |>
purrr::modify_at("law", str2lang)
jsonlite::toJSON(as.list(identifier) |> purrr::modify_at("law", rlang::expr_deparse)) |> jsonlite::fromJSON()
jsonlite::toJSON(as.list(identifier) |> purrr::modify_at("law", rlang::expr_deparse)) |> jsonlite::fromJSON() |>
purrr::modify_at("law", as.call)
jsonlite::toJSON(as.list(identifier) |> purrr::modify_at("law", rlang::expr_deparse)) |> jsonlite::fromJSON() |>
purrr::modify_at("law", as.expression)
jsonlite::toJSON(as.list(identifier) |> purrr::modify_at("law", rlang::expr_deparse)) |> jsonlite::fromJSON() |>
purrr::modify_at("law", \(i) as.expression(i) |> as.call())
jsonlite::toJSON(as.list(identifier) |> purrr::modify_at("law", rlang::expr_deparse)) |> jsonlite::fromJSON() |>
purrr::modify_at("law", \(i) as.call(str2lang(paste(i, collapse = "\n"))))
jsonlite::toJSON(as.list(identifier) |> purrr::modify_at("law", rlang::expr_deparse)) |> jsonlite::fromJSON() |>
purrr::modify_at("law", \(i) str2lang(paste(i, collapse = "\n")))
library(smart.data)
identifier <- smart.data::as.taxonomy(list(term = "identifier", desc = "Identifies unique instances in a set"))
jsonlite::toJSON(as.list(identifier) |> purrr::modify_at("law", rlang::expr_deparse)) |> smart.data::as.taxonomy()
jsonlite::toJSON(as.list(identifier) |> purrr::modify_at("law", rlang::expr_deparse))
jsonlite::toJSON(as.list(identifier) |> purrr::modify_at("law", rlang::expr_deparse)) |> jsonlite::fromJSON() |>
purrr::modify_at("law", \(i) str2lang(paste(i, collapse = "\n")))
library(smart.data)
name_map <- Nnew("name_map", name_map = rlang::set_names(LETTERS))
name_map <- new("name_map", name_map = rlang::set_names(LETTERS))
rm(name_map)
new("name_map", name_map = rlang::set_names(LETTERS))
new("name_map", name_map = rlang::set_names(letters, LETTERS))
smart.data::new("name_map", name_map = rlang::set_names(LETTERS))
library(smart.data)
names(mtcars) |> paste(collapse = ", ") |> writeClipboard()
head(mtcars)
?mtcars
orig_data <- data.table::as.data.table(mtcars, keep.rownames = TRUE) |> data.table::setnames("rn", "make_model")
data_names <- (\(x) rlang::set_names(x, toupper(x)))(names(orig_data))
orig_data <- data.table::as.data.table(mtcars, keep.rownames = TRUE) |> data.table::setnames("rn", "make_model")
data_names <- (\(x) rlang::set_names(x, toupper(x)))(names(orig_data))
#
# ~ PART I: Functionality Tests ====
smrt <- smart.data$
new(x = orig_data, name = "smart_cars")$
naming.rule(!!!data_names)$
enforce.rules(for_naming)
smrt$taxonomy.rule(gui = TRUE)
library(smart.data)
#
# ~ PART I: Functionality Tests ====
smrt <- smart.data$
new(x = orig_data, name = "smart_cars")$
naming.rule(!!!data_names)$
enforce.rules(for_naming)
smrt$taxonomy.rule(gui = TRUE)
taxonomy(term = "", desc = "")
smrt$taxonomy.rule(
identifier = taxonomy(term = "identifier", desc = "Make and Model")
, performance = taxonomy(term = "performance", desc = "Performance stats")
, metrics  = taxonomy(term = "metrics", desc = "Physical Metrics")
, characteristics = taxonomy(term = "characteristics", desc = "Categorical Descriptors")
, gui = TRUE
)$enforce.rules(for_usage)
